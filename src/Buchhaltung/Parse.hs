{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

{-|
Module      : Buchhaltung.Parse
Description : TODO
Copyright   : David Pätzel, 2019
License     : GPL-3
Maintainer  : David Pätzel <david.paetzel@posteo.de>
Stability   : experimental

TODO
-}
module Buchhaltung.Parse where

import Buchhaltung.Format
import Buchhaltung.Prelude hiding (many)
import Data.Decimal
import qualified Data.Text as T
import Data.Time.Format
import Hledger.Data
import Text.ParserCombinators.Parsec
import Prelude (read)

{-|
Maps combinations of bank code and account number (in that order) to account
names to be used in Hledger journal.
-}
type AccountNameMap = (String, String) -> AccountName

listtrans :: GenParser Char st (AccountNameMap -> [Transaction])
listtrans = fmap (\x accountNameMap -> fmap ($ accountNameMap) x) $ many line

line :: GenParser Char st (AccountNameMap -> Transaction)
line = do
  localAccountNumber' <- many (noneOf "#\n")
  char '#'
  localBankCode' <- many (noneOf "#\n")
  char '#'
  localIBAN <- many (noneOf "#\n")
  char '#'
  -- Sometimes we have account numbers, sometimes we only have IBANs, sometimes
  -- neither.
  let (localBankCode, localAccountNumber)
        | not . null $ localAccountNumber' = (localBankCode', localAccountNumber')
        | not . null $ localIBAN = fromIBAN localIBAN
        | otherwise = ("", "")
  date <-
    parseTimeOrError True defaultTimeLocale dateFormat <$> many (noneOf "#\n")
  char '#'
  valutaDate <-
    parseTimeOrError True defaultTimeLocale dateFormat <$> many (noneOf "#\n")
  char '#'
  remoteIBAN <- many (noneOf "#\n")
  char '#'
  remoteName <- many (noneOf "#\n")
  char '#'
  -- NOTE There must be a nicer way to parse to Decimals
  sign <- optionMaybe (char '-')
  digits1 <- many digit
  char '.'
  digits2 <- many digit
  let mantissa = fromIntegral $ length digits2
  let value = Decimal mantissa (read digits1 * 10 ^ mantissa + read digits2)
  char '#'
  purpose <- many (noneOf "\n")
  char '\n'
  return $ \mapping ->
    nulltransaction
      { tcomment =
          "\n"
            <> "Generated by buchhaltung2\n"
            <> "Local bank code: "
            <> T.pack localBankCode
            <> "\n"
            <> "Local account number: "
            <> T.pack localAccountNumber
            <> "\n"
            <> "Remote IBAN: "
            <> T.pack remoteIBAN
            <> "\n"
            <> "Remote Name: "
            <> T.pack remoteName
            <> "\n",
        tdate = date,
        tdate2 = Just valutaDate,
        tdescription = T.pack purpose,
        tpostings =
          [ post (mapping (localBankCode, localAccountNumber))
              $ (eur value) {acommodity = "EUR", astyle = amountStyle},
            post "TODO"
              $ (eur $ negate value) {acommodity = "EUR", astyle = amountStyle}
          ]
      }

{-|
Extracts bank code and account number from an IBAN (assuming German IBANs
without spaces).
-}
fromIBAN :: String -> (String, String)
fromIBAN iban =
  let bankCode = take 8 . drop 4 $ iban
      accountNumber = dropWhile (== '0') . drop (8 + 4) $ iban
   in (bankCode, accountNumber)

amountStyle :: AmountStyle
amountStyle =
  AmountStyle
    { ascommodityside = R,
      ascommodityspaced = True,
      asprecision = 2,
      asdecimalpoint = Just ',',
      asdigitgroups = Nothing
    }

prop_exampleLineParses =
  isRight . parse line "" $ exampleLine

return []

runTests = $quickCheckAll
